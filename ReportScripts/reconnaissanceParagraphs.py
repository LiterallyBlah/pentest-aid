from docx import Document
from Scripts import clearConsole
import json


def main(json_file):
    # opens data.json and stores the variables dictionary data.
    with open(json_file) as f:
        data = f.read()
    jsonData = json.loads(data)

    # grabs basic information found in the data.json - then used in the variables function.
    global variables
    variables = {
        "{{Client}}": jsonData['{{Client}}'],
        "outputDoc": jsonData['outputDoc']
    }

    # Select the name of the document you would like the output to direct to. (you can include output path too)
    output_file_path = variables['outputDoc']

    # grabs basic information found in the data.json - then used in the variables function.
    global output_document
    output_document = Document(output_file_path)

    reconOptions()
    addHeaders()

    # opens data.json and stores the variables dictionary data.


    # grabs basic information found in the data.json - then used in the variables function.

    variables = {
        "{{Client}}": jsonData['{{Client}}'],
        "assessmentSelection": jsonData['assessmentSelection']
    }


    ReplaceVariables()
    # Save changes to the output file.
    output_document.save(output_file_path)


# for the key and value in the variables dictionary, look for the key in the template docx file and replace with value.
# this applies to both tables and regular paragraphs. I haven't tested it with text boxes.
def ReplaceVariables():
    for key, value in variables.items():
        replace_text_in_paragraph(key, value)

    for key, value in variables.items():
        replace_text_in_table(key, value)


# Search and replace function for paragraphs.
def replace_text_in_paragraph(search, replace):
    # for every paragraph in docx template,
    for paragraph in output_document.paragraphs:
        # if what you search for is in the paragraph text,
        if search in paragraph.text:
            inline = paragraph.runs
            # for every word in the paragraph text,
            for item in inline:
                # if what you search is in the text,
                if search in item.text:
                    # the text is replaced by what you set.
                    item.text = item.text.replace(search, replace)


# Search and replace function for tables
def replace_text_in_table(search, replace):
    # for every table in the docx template,
    for table in output_document.tables:
        # look at every row in the tables,
        for row in table.rows:
            # for every cell in the rows,
            for cell in row.cells:
                # for every paragraph in the cells,
                for paragraph in cell.paragraphs:
                    # if what you search for is in the paragraph,
                    if search in paragraph.text:
                        # replace the search with what you want to replace it with.
                        paragraph.text = paragraph.text.replace(search, replace)


# This function stores the recon paragraphs and adds them to the output docx file.
def reconOptions():
    clearConsole.clearConsole()

    print("Please choose one or more of the below sections to add.\nSeperate by spaces. Example: 1 3 2 4")
    num = 0
    # for each recon option,
    for item in recon_paragraphs.keys():
        # print a number with '. ' and then the option,
        num = num + 1
        print(str(num) + '. ' + item)

    global reconChoices
    reconChoices = input("\n\n> ")
    reconChoices = reconChoices.split()


    # paragraphs is equal to the paragraphs stored in the docx template.
    paragraphs = output_document.paragraphs

    num = 0
    # for each key in the reconnaissance paragraph dictionary,
    for key in recon_paragraphs.keys():
        num = num + 1
        # check to see if the number and key were under the paragraph selection.
        addParagraph(str(num), key)

    # for every paragraph in the output docx file,
    for paragraph in paragraphs:
        # replace {{RECONNAISSANCE}} with nothing.
        if '{{RECONNAISSANCE}}' in paragraph.text:
            delete_paragraph(paragraph)


def delete_paragraph(paragraph):
    p = paragraph._element
    p.getparent().remove(p)
    p._p = p._element = None


# Add paragraphs selected by the user.
def addParagraph(num, para):
    paragraphs = output_document.paragraphs
    # if the number is in the selected paragraphs,
    if num in reconChoices:
        # for each paragraph in the output docx file,
        for paragraph in paragraphs:
            # if {{RECONNAISSANCE}} is in the paragraph text,
            if '{{RECONNAISSANCE}}' in paragraph.text:
                # insert paragraph before {{RECONNAISSANCE}}.
                # NOTE: each paragraph inserted is a block of XML. It is essential to insert each paragraph one-by-one.
                # If you don't, then the headers will cluster together.
                # The headers insert themselves before the XML block of each paragraph.
                paragraph.insert_paragraph_before(text=recon_paragraphs[para]).text


# Adds headers before paragraphs.
def addHeaders():
    paragraphs = output_document.paragraphs

    # for key and value found in the recon paragraphs dictionary,
    for key, value in recon_paragraphs.items():
        # for every paragraph in the output docx paragraphs,
        for paragraph in paragraphs:
            # if the value is found in the paragraph text,
            if value in paragraph.text:
                # insert header before paragraph
                paragraph.insert_paragraph_before(text=key, style="Heading 3").text


# Simply add some paragraphs here, and it should add them as an option without issue... It "should".
global recon_paragraphs
recon_paragraphs = {
    "FTP": "The File Transfer Protocol (FTP) is a standard network protocol used for the transfer of computer "
           "files between a client and server on a computer network. During Out reconnaissance, we enumerated "
           "over this service to find any information that may provide further insight.\n\nPort scanning is the "
           "first step we take to identify any open FTP ports. In the listed ports, you can see that we have "
           "identified FTP ports, which we can now further enumerate. Banner grabbing is a simple technique to "
           "acquire information about the service. It’s as simple as connecting to the service and reviewing the "
           "response it gives. This usually will provide basic information about the service such as the server "
           "used and the version of the server.\n\n<FTP-Banner>\n\nIf we have basic access such as an anonymous "
           "account, which by default, some servers have enabled. We can enumerate over any commands we can use. "
           "Depending on the available commands, this can be especially useful.\n\n<Anon-enum>\n\n",
    "SSH": "SSH or Secure Shell or Secure Socket Shell, is a network protocol that gives users a secure way to "
           "access a device over an unsecured network. During Out reconnaissance, we enumerated over this service "
           "to find any information that may provide further insight.\n\nAs SSH is such a common service, "
           "we have a plethora of scripts available for helping us gain information. Along with manual assessing, "
           "we were able to find how this SSH service was configured. \n\nWe started with banner grabbing to help "
           "recognize the device, software and operating system. This is a simple process which only entails "
           "connecting to the service. Depending on the configuration, we may receive no "
           "information.\n\n<SSH-Banner>\n\nNext we focused on gathering the key-exchange method, host-key, "
           "encryption and message authentication code algorithms. From the output, we are able to determine "
           "secure communications between client and server.\n\n<SSH-Encryption>\n\n",
    "Telnet": "Telnet is a network protocol that gives users an unsecured way to access a device over a network. "
              "During Out reconnaissance, we enumerated over this service to find any information that may "
              "provide further insight.\n\nWe first start with banner grabbing to find any potentially sensitive "
              "information, such as the FTP server software and its version. This is a common misconfiguration "
              "seen in most servers.\n\n<Telnet-banner>\n\n",
    "SMTP": "SMTP (Simple Mail Transfer Protocol) is a TCP/IP protocol used in sending and receiving e-mail. "
            "However, since it is limited in its ability to queue messages at the receiving end, it is usually "
            "used with one of two other protocols, POP3 or IMAP, that let the user save messages in a server "
            "mailbox and download them periodically from the server.\n\nIn other words, users typically use a "
            "program that uses SMTP for sending e-mail and either POP3 or IMAP for receiving e-mail. On "
            "Unix-based systems, sendmail is the most widely-used SMTP server for e-mail. A commercial package, "
            "Sendmail, includes a POP3 server. Microsoft Exchange includes an SMTP server and can also be set up "
            "to include POP3 support.\n\nOur first step is to grab the banner of this service. This is done by "
            "simply connecting to it. \n\n<SMTP-banner>\n\nSMTP commonly doesn’t require credentials to create a "
            "session. By connecting to this service, we can find further information by enumerating over SMTP "
            "commands, thereby exposing more information.\n\n<SMTP-Enum>\n\n",
    "DNS": "The Domain Name Systems (DNS) is the phonebook of the Internet. Humans access information online "
           "through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol ("
           "IP) addresses. DNS translates domain names to.\n\nAs with most services, we start with banner grabbing. "
           "This can expose the DNS software and potentially its version.\n\n<DNS-banner>\n\nWe can then enumerate "
           "over the service using DNS requests, giving us further insight into the service and its "
           "configuration.\n\n<DNS-enum>\n\nFrom this point, we can attempt a zone transfer. DNS zone transfer, "
           "also known as DNS query type AXFR, is a process by which a DNS server passes a copy of part of its "
           "database to another DNS server. The portion of the database that is replicated is known as a zone. "
           "\n\n<DNS-ZT>\n\n ",
    "Finger": "Finger is a program you can use to find information about computer users. It usually lists the "
              "login name, the full name, and possibly other details about the user you are fingering. These "
              "details may include the office location and phone number (if known), login time, idle time, "
              "time mail was last read, and the user's plan and project files.\n\nAs with most services, "
              "we start with banner grabbing. This can expose the DNS software and potentially its "
              "version.\n\n<Finger-banner>\n\nFrom here, we can start directly enumerating over systems and users to "
              "gather their information.\n\n<Finger-enum>\n\n",
    "HTTP": "HTTP is a protocol to communicate with the client and the server (web server) via a user-agent (web "
            "browser like firefox, chrome, IE etc). The client browser sends a request to the server, "
            "and then the server responds to this request. HTTP has the advantages of being a text protocol and "
            "therefore really easy to read, understand and learn for a human being. By default, most web servers "
            "are available on port TCP/80 and TCP/443. When your browser connects to a URL: http://google.com, "
            "it's in fact doing a TCP connection to the port 80 of the IP corresponding to the name "
            "google.com.\n\nThe HTTP web service is the most common and extensive service and a lot of different "
            "types of vulnerabilities exists.\n\nAs with most services, we start with banner grabbing. This can "
            "expose the DNS software and potentially its version.\n\n<HTTP-banner>\n\nAnd for further data, "
            "we can look at the response headers.\n\n<HTTP-headers>\n\nBefore actively moving on to other aspects "
            "where we uncover information, we first need to determine whether there is a web application "
            "firewall. This is so we prevent us from being blocked, as the following tests will make many "
            "requests.\n\n<HTTP-waf>\n\nWe can then move on to directory brute-forcing after crawling the web "
            "service. Crawling will list all the available directories web pages expose. By bruteforcing, "
            "we can identify any directories that were not under the average web page.\n\n<HTTP-brute>\n\n",
    "Kerberos": "Firstly, Kerberos is an authentication protocol, not authorization. In other words, it allows to "
                "identify each user, who provides a secret password, however, it does not validate which "
                "resources or services can this user access.\n\nKerberos is used in Active Directory. In this "
                "platform, Kerberos provides information about the privileges of each user, but it is "
                "responsibility of each service to determine if the user has access to its resources.\n\nSeeing "
                "that we have no credentials, we have to start by brute-forcing usernames. "
                "\n\n<Kerberos-User-Brute>\n\nOnce this is done, we can continue by brute-forcing the discovered "
                "usernames with password combinations.\n\n<Kerberos-User-Pass>\n\n",
    "POP": "Post Office Protocol (POP) is a type of computer networking and Internet standard protocol that "
           "extracts and retrieves email from a remote mail server for access by the host machine. POP is an "
           "application layer protocol in the OSI model that provides end users the ability to fetch and receive "
           "email.\n\nThe POP clients generally connect, retrieve all messages, store them on the client system, "
           "and delete them from the server. There are 3 versions of POP, but POP3 is the most used one.\nAs with "
           "most services, we start with banner grabbing. This can expose the DNS software and potentially its "
           "version.\n\n<POP-banner>\n\nWE can then move on to brute-forcing the credentials to gain access to this "
           "service.\n\n<POP-brute>\n\n",
    "MSRPC": "Microsoft Remote Procedure Call, also known as a function call or a subroutine call, is a protocol "
             "that uses the client-server model in order to allow one program to request service from a program "
             "on another computer without having to understand the details of that computer's network. MSRPC was "
             "originally derived from open source software but has been developed further and copyrighted by "
             "Microsoft.\n\nDepending on the host configuration, the RPC endpoint mapper can be accessed through "
             "TCP and UDP port 135, via SMB with a null or authenticated session (TCP 139 and 445), and as a web "
             "service which commonly listens on TCP port 593.\n\nWe first start by identifying any MSRPC "
             "ports.\n\n<MSRPC-ports>\n\nWe can then attempt to enumerate over the service to find any valuable "
             "information.\n\n<MSRPC-enum>\n\n ",
    "NetBios": "Every machine should have a name inside the NetBios network. To request a name, a machine should "
               "send a 'Name Query' packet in broadcast and if anyone answer that it is already using that name, "
               "the machine can use that name. If there is a Name Service server, the computer could ask the Name "
               "Service server if someone is using the name that it wants to use.\n\nTo discover the IP address of "
               "a Name, a PC has to send a 'Name Query' packet and wait if anyone answers. If there is a Name "
               "Service server, the PC can ask it for the IP of the name.\nWe can enumerate over the NetBios "
               "service and find the data associated with it.\n\n<NB-enum>\n\n",
}


if __name__ == '__main__':
    main()
